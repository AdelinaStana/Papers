
\documentclass[a4paper,twoside]{article}

\usepackage{epsfig}
\usepackage{subcaption}
\usepackage{calc}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{multicol}
\usepackage{pslatex}
\usepackage{apalike}
\usepackage{graphicx}
\usepackage{booktabs,chemformula}
\usepackage{SCITEPRESS}     % Please add other packages that you may need BEFORE the SCITEPRESS.sty package.

\graphicspath{ {images/} }
\begin{document}

\title{Identifying logical dependencies from co-changing classes}


\author{\authorname{Adelina Diana Stana, Ioana \c{S}ora}
\affiliation{
Department of Computer and Information Technology, \\ Politehnica University Timisoara, Romania}
}



\keywords{software evolution, logical dependencies, structural dependencies}

\abstract{
Emerging software engineering approaches support the idea that logical dependencies should be included next to structural dependencies in general methods and tools for dependency management.  However, logical dependencies are still hard to identify, as not all co-changes during the system evolution represent true logical dependencies. Our work identifies a set of factors that can be used to filter the recordings of class co-changes in order to find valid logical dependencies. In order to find the characteristics of logical dependencies, we analyze the quantitative relationships between the sets of logical and structural dependencies and their intersection and differences. We present results obtained through an experimental study on a set of 27
open source software projects written in Java and C\# with their historical evolutions which sum up to over 70000 commit transactions. Identifying valid logical dependencies from co-changing classes will enhance dependency models used in various software analysis activities.
}

\onecolumn \maketitle \normalsize \setcounter{footnote}{0} \vfill



\section{Introduction}
\label{sec:intro}

Coupling reflects the degree of interdependence between different software modules, being a measure of how closely connected they are. Coupling should be low in order to ensure the testability, reusability, and evolvability properties of modules. The traditional approach on coupling was to quantify the structural dependencies or interactions between modules, which both can be determined by source code analysis.
   
The state of the art has found that modules may present different kinds and degrees of interdependence, even if no structural dependencies can be found by analyzing the source code. Gall \cite{Gall:1998:DLC:850947.853338} identified as logical coupling between two modules the fact that these modules repeatedly change together during the historical evolution of the software system. This can be an indicator of a logical dependency between these modules.

The concepts of logical coupling and logical dependencies were first used in different analysis tasks, all related to changes: for software change impact analysis \cite{1553643}, for identifying the potential ripple effects caused by software changes during software maintenance and evolution \cite{DBLP:conf/issre/OlivaG15}, \cite{Oliva:2011:ISL:2067853.2068086}, \cite{Poshyvanyk2009}, \cite{posh2010} or for their link to deffects \cite{wiese}, \cite{Zimmermann:2004:MVH:998675.999460}.

The current trend recommends that general dependency management methods and tools should also include logical dependencies besides the structural dependencies \cite{Oliva:2011:ISL:2067853.2068086}, \cite{DBLP:journals/jss/AjienkaC17}. Different applications based on dependency analysis could be improved if, beyond structural dependencies, they also take into account the hidden non-structural dependencies. For example, works  which investigate different methods for architectural reconstruction \cite{SoraConti}, \cite{SoraSem13}, \cite{PagerankENASE},  all of them based on the information provided by structural dependencies, could enrich their dependency models by taking into account also logical dependencies. However, a thorough survey \cite{sar} shows that historical information has been rarely used in architectural reconstruction. Another survey \cite{Shtern:2012:CMS:2332427.2332428} mentions one possible explanation why historical information have been rarely used in architectural reconstruction: the size of the extracted information. One problem is the size of the extraction process, which has to analyze many versions from the historical evolution of the system. Another problem is the big number of pairs of classes which record co-changes and how they relate to the number of pairs of classes with structural dependencies. Logical dependencies should integrate harmoniously with structural dependencies in an unitary dependency model: valid logical dependencies should not be omitted from the dependency model, but structural dependencies should not be engulfed by questionable logical dependencies generated by casual co-changes.  
Thus, in order to add logical dependencies besides structural dependencies in dependency models, class co-changes must be filtered until they remain only a reduced but relevant set of valid logical dependencies. 


In the next section we analyze the state of the art results for determining logical dependencies from the point of view of their quantitative relationship with structural dependencies. Starting from this analysis, in Section \ref{sec:question} we identify a set of factors that can be used to filter the recordings of class co-changes such that valid logical dependencies are identified and we formulate the research questions. In order to answer these research questions, we have built a tool that extracts structural and logical dependencies in different scenarios. We have analyzed several open-source software systems of different sizes with our tool, obtaining the experimental results presented in Section \ref{sec:experiments}. Section \ref{sec:discussion} discusses the experimental results and answers the research questions.
 


\section{State of the art}
\label{sec:state}


There are researches that investigated quantitative aspects of logical dependencies and their interplay with structural dependencies. 
Oliva and Gerosa \cite{Oliva:2011:ISL:2067853.2068086}, \cite{DBLP:conf/issre/OlivaG15} have found first that the set of co-changed classes was much larger compared to the set of structurally coupled classes. They identified structural and logical dependencies from 150000 revisions from the Apache Software Foundation SVN repository. Also they concluded  that in at least 91\% of the cases, logical dependencies involve files that are not structurally related. This implies that not all of the change dependencies are related to structural dependencies and there could be other reasons for software artifacts to be change dependent.

Ajienka and Capiluppi also studied the interplay between logical and structural coupling of software classes. In \cite{DBLP:journals/jss/AjienkaC17} they  perform experiments on 79 open source systems: for each system, they determine the sets of structural dependencies, the set of logical dependencies and the intersections of these sets. They quantify the overlapping or intersection of these sets, coming to the conclusion that not all co-changed class pairs (classes with logical dependencies) are also linked by structural dependencies. One other interesting aspect which has not been investigated by the authors in \cite{DBLP:journals/jss/AjienkaC17}  is the total number of logical dependencies, reported to the total number of structural dependencies of a software systems. However, they provide the raw data of their measurements and we calculated the ratio between the number of logical dependencies and the number of structural dependencies for all the projects analyzed by them: the average ratio resulted 12.  This means that, using their method of detecting logical dependencies for a system, the number of logical dependencies outnumbers by one order of magnitude the number of structural dependencies. We consider that such a big number of logical dependencies needs additional filtering. 


Another kind of non-structural dependencies are the semantic or conceptual dependencies \cite{Poshyvanyk2009}, \cite{posh2010}. Semantic coupling is given by the degree to which the identifiers
and comments from different classes are similar to each other. Semantic coupling could be an indicator for logical dependencies, as studied by Ajienka et al in \cite{DBLP:journals/ese/AjienkaCC18}. The experiments showed that a large number of co-evolving classes do not present semantic coupling, adding to the earlier research which showed that a large number of co-evolving classes do not present structural coupling. All these experimental findings rise the question whether it is a legitimate approach to accept all co-evolving classes as logical coupling.


Changes made to two components in the same commit do not necessarily indicate the co-evolution of the two. These changes could be completely unrelated. The study \cite{Yu2007} acknowledges the fact that evolutionary coupling could also be determined accidentally by two components changing in the same commit (independent evolution, as it is called) and this will bring noise to the measurement of evolutionary coupling. 


Zimmermann et al \cite{Zimmermann:2004:MVH:998675.999460} introduced data mining techniques to obtain association
rules from version histories.
The mined association rules  have a probabilistic interpretation based on the amount of
evidence in the transactions they are derived from. This
amount of evidence is determined by two measures: 
support and confidence.  They developed a tool to predict future or
missing changes.

In order to add logical dependencies besides structural dependencies as inputs for methods and tools for dependency management and analysis, class co-changes must be filtered until they remain only a reduced but relevant set of valid logical dependencies. 

\section{Research questions}
\label{sec:question}

In this work, we explore several ways of filtering logical dependencies.  We identify following factors that could be used to filter logical dependencies: the maximum size of commit transactions which are accepted to generate logical dependencies, the minimum number of occurrences for a co-change to be considered a logical dependency, and accepting changes in comments as a source of logical dependencies. 

We will address the following research questions:

\textit{\textbf{Question 1}}. Which is the most frequent size for a commit transaction ?  

\textit{Motivation}: We calculate the size for a commit transaction as the total number of source code files that have changed. Even though the versioning systems best practices encourage developers to commit often which implies small size commit transactions, the size of the commit transaction relies also on the developers culture. We think that finding the most frequent size for a commit transaction could help into setting ranges for what is a normal size commit transaction for the systems. And also to set a target commit transaction group from which we can extract logical dependencies.

\textit{\textbf{Question 2}}.Is it necessary to set a threshold on the size of commit transactions which are considered to generate valid logical dependencies ?

\textit{Motivation}: A big commit transaction can indicate that a merge with another branch or a folder renaming has been made. In this case, a series of irrelevant logical dependencies can be introduced since not all the files are updated in the same time for a development reason. Different works have chosen fixed threshold values for the maximum number of files accepted in a commit. Cappiluppi and Ajienka, in their works \cite{DBLP:journals/jss/AjienkaC17}, \cite{DBLP:journals/ese/AjienkaCC18} only take into consideration commits with less then 10 source code files changed in building the logical dependencies. The research of Beck et al \cite{Beck:2011:CMC:2025113.2025162} only takes in consideration transactions with up to 25 files. The research \cite{Oliva:2011:ISL:2067853.2068086} provided also a quantitative analysis of the number of files per revision; Based on the analysis of  40,518 revisions, the mean value obtained for the number of files in a revision is 6 files. However, standard deviation value shows that the dispersion is high. Based on all these considerations, we will experiment with different threshold values for the maximum size of commit transactions which are accepted to generate logical dependencies.


\textit{\textbf{Question 3}}. Considering changes which are only in comments as valid can lead to additional logical dependencies? How many logical dependencies are introduced by considering comment changes as valid changes and in what percentage can this influence the analysis?

\textit{Motivation}: Not all the commits that have source code files changed include real code changes, some of them can be only comments changes. We consider that there is probably no logical dependency between two classes that change in the same time only by comments changes. It could be that someone is adding implementation documentation or copyright or ownership information. Some studies have not considered this aspect, so we will analyse the impact of considering/not considering changes in  comments as valid logical dependencies. 


\textit{\textbf{Question 4}}. How many occurrences of a logical dependency are needed to consider it a \textit{valid} logical dependency ? 

\textit{Motivation}: One occurrence of a logical dependency between two classes can be a valid logical dependency, but can also be a coincidence. Taking into consideration only logical dependencies with multiple occurrences as valid dependencies can lead to more accurate logical dependencies and more accurate results. On the other hand, if the project studied has a relatively small amount of commits, the probability to find multiple updates of the same classes in the same time can be small, so filtering after the number of occurrences can lead to filtering all the logical dependencies extracted. Giving the fact that we will study multiple projects of different sizes and number of commits, we will analyze also the impact of this filtering on different projects.

\textit{\textbf{Question 5}}. How does filtering affect the overlap between structural and logical dependencies ? 

\textit{Motivation}: Traditional software engineering considers coupling as the cause for co-changes, thus logical and structural dependencies should present a very big overlap. However, in \cite{Oliva:2011:ISL:2067853.2068086} and \cite{DBLP:journals/jss/AjienkaC17} it has been experimentally determined that a very large number of logical dependencies are outside the intersection with structural dependencies. We will investigate the influence of different filtering degrees on the intersections between logical and structural dependencies.  



\section{Experimental results}
\label{sec:experiments}


We have analyzed a set of open-source projects found on GitHub\footnote{http://github.com/} \cite{Kalliamvakou2016} in order to extract the structural and logical dependencies between classes. Table \ref{table:1} enumerates all the systems studied. The 1st column assigns the projects IDs; 2nd column shows the project name; 3rd column shows the number of entities (classes and interfaces) extracted; 4th column shows the number of most recent commits analyzed from the active branch of each project and the 5th column shows the language in which the project was developed.
\begin{table}[!h]
\renewcommand{\arraystretch}{1.05}
\caption{Summary of open source projects studied.}
\label{table:1}
\centering
\begin{tabular}{|c|c|c|c|c|c|}
\hline
   ID  & Project    & Nr. of & Nr. of& Type\\
     &     & entites & commits & \\
\hline
1	&	bluecove	&	586	&	894	&	java	\\
2	&	aima-java	&	987	&	818	&	java	\\
3	&	powermock	&	1084	&	893	&	java	\\
4	&	restfb	&	783	&	1188	&	java	\\
5	&	rxjava	&	2673	&	2468	&	java	\\
6	&	metro-jax-ws	&	1103	&	2222	&	java	\\
7	&	mockito	&	1409	&	1572	&	java	\\
8	&	grizzly	&	1592	&	3122	&	java	\\
9	&	shipkit	&	242	&	1483	&	java	\\
10	&	OpenClinica	&	1653	&	3749	&	java	\\
11	&	robolectric	&	2050	&	5029	&	java	\\
12	&	aeron	&	541	&	5101	&	java	\\
13	&	antlr4	&	1381	&	3449	&	java	\\
14	&	mcidasv	&	805	&	3668	&	java	\\
15	&	ShareX	&	919	&	2505	&	C\#	\\
16	&	aspnetboilerplate	&	2353	&	1615	&	C\#	\\
17	&	orleans	&	3485	&	3353	&	C\#	\\
18	&	cli	&	767	&	2397	&	C\#	\\
19	&	cake	&	2250	&	1853	&	C\#	\\
20	&	Avalonia	&	1677	&	2445	&	C\#	\\
21	&	EntityFramework	&	7107	&	2443	&	C\#	\\
22	&	jellyfin	&	2179	&	4065	&	C\#	\\
23	&	PowerShell	&	861	&	2033	&	C\#	\\
24	&	WeiXinMPSDK	&	2029	&	2723	&	C\#	\\
25	&	ArchiSteamFarm	&	117	&	2181	&	C\#	\\
26	&	VisualStudio	&	1016	&	4417	&	C\#	\\
27	&	CppSharp	&	259	&	3882	&	C\#	\\
\hline
\end{tabular}
\end{table}


In a first experiment, we determined the commit sizes $cs$ for all commit transactions for all projects and grouped them into 4 categories: small transactions (ST), when 	$cs\leq 5$; medium transactions (MT), when 	$5 < cs\leq 10$; large transactions (LT), when 	$10 < cs\leq 20$; and very large transactions (VLT), when 	$20 < cs$. Also, we counted how many logical dependencies are generated by transactions  from each category. The results are presented in Tables \ref{table:5} and \ref{table:6} as percent distributions.


\begin{table}[!h]
\renewcommand{\arraystretch}{1}
%\caption{The distribution of commit size in percentage relative to the total number of commits of the system }
\caption{The percent distribution of commit transactions in 4 categories according to their size}


\label{table:5}
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
   &	ST	&	 MT	&	LT	&	VLT	\\
\hline
1	&	82.55	&	10.85	&	4.14	&	2.46	\\
2	&	71.39	&	13.08	&	7.82	&	7.7	\\
3	&	73.91	&	13.33	&	6.27	&	6.49	\\
4	&	84.51	&	8.5	&	3.11	&	3.87	\\
5	&	75.2	&	11.26	&	5.92	&	7.62	\\
6	&	87.8	&	6.35	&	2.57	&	3.29	\\
7	&	78.18	&	11.96	&	5.73	&	4.13	\\
8	&	79.63	&	9.67	&	5.77	&	4.93	\\
9	&	83.82	&	9.58	&	4.18	&	2.43	\\
10	&	82.58	&	9.66	&	5.31	&	2.45	\\
11	&	82.96	&	8.55	&	4.89	&	3.6	\\
12	&	87.69	&	8.51	&	2.96	&	0.84	\\
13	&	81.19	&	8.23	&	5.54	&	5.03	\\
14	&	96.7	&	1.94	&	0.71	&	0.65	\\
15	&	89.27	&	7.11	&	2.17	&	1.45	\\
16	&	77.28	&	12.76	&	5.51	&	4.46	\\
17	&	70.3	&	12.53	&	9.48	&	7.69	\\
18	&	73.93	&	12.27	&	6.63	&	7.18	\\
19	&	69.99	&	14.41	&	6.91	&	8.69	\\
20	&	68.79	&	10.1	&	7.44	&	13.66	\\
21	&	60.66	&	17.63	&	10.04	&	11.66	\\
22	&	73.97	&	12.63	&	6.94	&	6.47	\\
23	&	83.13	&	6.64	&	4.18	&	6.05	\\
24	&	79.43	&	8.56	&	5.66	&	6.35	\\
25	&	94.54	&	3.62	&	1.1	&	0.73	\\
26	&	76.21	&	9.74	&	5.84	&	8.22	\\
27	&	86.17	&	8.53	&	4.12	&	1.18	\\
\hline
Avg	&	79.7	&	9.93	&	5.22	&	5.16	\\
\hline
\end{tabular}
\end{table}

\begin{table}[!h]
\renewcommand{\arraystretch}{1}
%\caption{Percentage of LD extracted from different commit size chunks relative to the total number of LD of the system }
\caption{The percent distribution of logical dependencies generated by commit transactions from each size category}
\label{table:6}
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
   &	ST	&	MT	&	LT	&	VLT	\\
\hline
1	&	9,70	&	2,61	&	4,12	&	83,57	\\
2	&	1,50	&	1,87	&	3,59	&	93,03	\\
3	&	3,75	&	5,02	&	5,97	&	85,26	\\
4	&	31,40	&	7,64	&	8,84	&	52,12	\\
5	&	1,01	&	3,92	&	4,67	&	90,41	\\
6	&	0,37	&	0,22	&	0,47	&	98,94	\\
7	&	1,48	&	1,86	&	2,48	&	94,18	\\
8	&	1,44	&	2,01	&	3,73	&	92,82	\\
9	&	6,77	&	7,88	&	11,99	&	73,36	\\
10	&	12,53	&	17,77	&	21,59	&	48,10	\\
11	&	6,80	&	8,25	&	13,74	&	71,22	\\
12	&	22,09	&	21,73	&	20,51	&	35,67	\\
13	&	10,46	&	20,48	&	8,08	&	60,98	\\
14	&	1,90	&	0,90	&	1,29	&	95,91	\\
15	&	1,14	&	1,25	&	1,86	&	95,76	\\
16	&	1,89	&	2,47	&	3,12	&	92,52	\\
17	&	2,13	&	2,19	&	5,25	&	90,44	\\
18	&	1,77	&	3,66	&	6,51	&	88,06	\\
19	&	0,59	&	0,68	&	1,57	&	97,17	\\
20	&	0,41	&	0,73	&	1,42	&	97,45	\\
21	&	1,50	&	1,22	&	37,85	&	59,43	\\
22	&	2,00	&	4,12	&	5,95	&	87,92	\\
23	&	1,02	&	1,22	&	0,94	&	96,82	\\
24	&	0,71	&	0,74	&	1,63	&	96,91	\\
25	&	37,86	&	16,51	&	11,12	&	34,50	\\
26	&	2,86	&	3,22	&	6,79	&	87,13	\\
27	&	23,43	&	21,56	&	28,28	&	26,73	\\
\hline
Avg	&	6,98	&	5,99	&	8,27	&	78,76	\\
\hline
\end{tabular}
\end{table}



In the main series of experiments, for each system, we extracted its structural dependencies, its logical dependencies and determined the overlap between the two dependencies sets, in various experimental conditions. 

One variable experimental condition is whether changes located in comments contribute towards logical dependencies. This condition distinguishes between two different cases: 
\begin{itemize}
	\item with comments: a change in source code files is counted towards a logical dependency, even if the change is inside comments in all files
	\item without comments: commits that changed source code files only by editing comments are ignored as logical dependencies
\end{itemize}

In all cases, we varied the following threshold values: 
 \begin{itemize}
	\item commit size ($cs$): the maximum size of commit transactions which are accepted to generate logical dependencies. The values for this threshold were 5, 10, 20 and no threshold (infinity).  
	\item number of occurrences ($occ$): the minimum number of repeated occurrences for a co-change to be counted as logical dependency. The values for this threshold were 1, 2, 3 and 4.  
\end{itemize}

The six tables below present the synthesis of our experiments. 
We have computed the following  values:
\begin{itemize}
	\item the mean ratio of the number of logical dependencies  (LD) to the number of structural dependencies (SD)
   \item the mean percentage of structural dependencies that are also logical dependencies (calculated from the number of overlaps divided to the number of structural dependencies)	
		\item the mean percentage of logical dependencies that are also structural dependencies (calculated from the number of overlaps divided to the number of logical dependencies)
\end{itemize}

In all the six tables, \ref{tab:ratio:comm}, \ref{tab:ratio:nocomm}, \ref{tab:percSD:comm}, \ref{tab:percSD:nocomm},
\ref{tab:percLD:comm}, \ref{tab:percLD:nocomm} we have on columns the values used for the commit size $cs$, while on rows we have the values for the number of occurrences threshold $occ$. The tables contain median values obtained for experiments done under all combinations of the two threshold values, on all test systems. In all tables, the upper right corner corresponds to the most relaxed filtering conditions, while the lower left corner corresponds to the most restrictive filtering conditions.


\begin{table}[!h]
%% increase table row spacing, adjust to taste
\renewcommand{\arraystretch}{1}
\caption{Ratio of number of LD to number of SD, case with comments}
\label{tab:ratio:comm}
\centering

\begin{tabular}{|c|c|c|c|c|}
\hline
	      &	$cs\leq 5$	&	$cs\leq 10$	&	$cs\leq 20$	&	$cs<\infty$	\\
\hline
$occ\geq 1$	&	3,39	&	5,67	&	9,00	&	80,31	\\
$occ\geq 2$	&	2,24	&	3,47	&	5,02	&	60,14	\\
$occ\geq 3$	&	1,04	&	2,53	&	3,52	&	44,68	\\
$occ\geq 4$	&	0,90	&	2,16	&	2,88	&	33,47	\\
\hline
\end{tabular}
\end{table}

\begin{table}[!h]
%% increase table row spacing, adjust to taste
\renewcommand{\arraystretch}{1}
\caption{Ratio of number of LD to number of SD, case without comments}
\label{tab:ratio:nocomm}
\centering

\begin{tabular}{|c|c|c|c|c|}
\hline
	      &	$cs\leq 5$	&	$cs\leq 10$	&	$cs\leq 20$	&	$cs< \infty$	\\
\hline
$occ\geq 1$	&	3,24	&	5,33	&	7,90	&	67,16	\\
$occ\geq 2$	&	1,35	&	3,27	&	4,72	&	47,39	\\
$occ\geq 3$	&	1,00	&	1,67	&	2,49	&	32,39	\\
$occ\geq 4$	&	0,43	&	1,26	&	1,93	&	22,15	\\
\hline
\end{tabular}
\end{table}

\begin{table}[!h]
%% increase table row spacing, adjust to taste
\renewcommand{\arraystretch}{1}
\caption{Percentage of SD that are also LD, case with comments}
\label{tab:percSD:comm}
\centering

\begin{tabular}{|c|c|c|c|c|}
\hline
	      &	$cs\leq 5$	&	$cs\leq 10$	&	$cs\leq 20$	&	$cs< \infty$	\\
\hline
$occ\geq 1$	&	19,75	&	29,86	&	39,29	&	76,59	\\
$occ\geq 2$	&	12,50	&	20,20	&	27,68	&	66,11	\\
$occ\geq 3$	&	8,49	&	14,22	&	19,94	&	55,99	\\
$occ\geq 4$	&	6,58	&	10,95	&	15,76	&	47,12	\\
\hline
\end{tabular}
\end{table}

\begin{table}[!h]
%% increase table row spacing, adjust to taste
\renewcommand{\arraystretch}{1}
\caption{Percentage of SD that are also LD, case without comments}
\label{tab:percSD:nocomm}
\centering

\begin{tabular}{|c|c|c|c|c|}
\hline
	      &	$cs\leq 5$	&	$cs\leq 10$	&	$cs\leq 20$	&	$cs< \infty$	\\
\hline
$occ\geq 1$	&	12,02	&	8,86	&	6,72	&	1,79	\\
$occ\geq 2$	&	15,05	&	11,71	&	9,38	&	2,21	\\
$occ\geq 3$	&	17,45	&	13,97	&	11,57	&	2,86	\\
$occ\geq 4$	&	18,96	&	15,28	&	12,94	&	3,67	\\
\hline
\end{tabular}
\end{table}

\begin{table}[!h]
%% increase table row spacing, adjust to taste
\renewcommand{\arraystretch}{1}
\caption{Percentage of LD that are also SD, case with comments}
\label{tab:percLD:comm}
\centering

\begin{tabular}{|c|c|c|c|c|}
\hline
	      &	$cs\leq 5$	&	$cs\leq 10$	&	$cs\leq 20$	&	$cs< \infty$	\\
\hline
$occ\geq 1$	&	12,02	&	8,86	&	6,72	&	1,79	\\
$occ\geq 2$	&	15,05	&	11,71	&	9,38	&	2,21	\\
$occ\geq 3$	&	17,45	&	13,97	&	11,57	&	2,86	\\
$occ\geq 4$	&	18,96	&	15,28	&	12,94	&	3,67	\\
\hline
\end{tabular}
\end{table}

\begin{table}[!h]
%% increase table row spacing, adjust to taste
\renewcommand{\arraystretch}{1}
\caption{Percentage of LD that are also SD, case without comments}
\label{tab:percLD:nocomm}
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
	      &	$cs\leq 5$	&	$cs\leq 10$	&	$cs\leq 20$	&	$cs< \infty$	\\
\hline
$occ\geq 1$	&	12,05	&	9,02	&	6,98	&	1,93	\\
$occ\geq 2$	&	15,08	&	12,03	&	9,66	&	2,42	\\
$occ\geq 3$	&	17,78	&	14,37	&	12,24	&	3,28	\\
$occ\geq 4$	&	19,22	&	15,59	&	13,30	&	4,21	\\
\hline
\end{tabular}
\end{table}

\section{Discussion}
\label{sec:discussion}


This section uses the experimental results to answer the research questions outlined in section \ref{sec:question}.


\textit{\textbf{Question 1}}. Which is the most frequent size for a commit transaction ?  

Table \ref{table:5} presents the size distribution for commit transactions in percentage relative to the total number of commits for each system presented in Table \ref{table:1}. The small commit transactions (with less than 5 source code files)represent in average 78.76\% from the total number of transactions. On the opposite side are the very large commit transactions (with more than 20 source code files) which represent an average percentage of 5.99\% from the total number of transactions. Based on these results we can say that the vast majority of the commit transactions have no more than 5 source code files.

\textit{\textbf{Question 2}}. Is it necessary to set a threshold on the size of commit transactions which are considered to generate valid logical dependencies ?
Logical dependencies are generated for all pairs of classes which have changed in the same commit transaction. The number of logical dependencies generated from a commit transaction is proportional with the square of the number of participating classes.  Table \ref{table:6} presents how many logical dependencies are extracted from commit transactions of different sizes. 
Based on the results from Table \ref{table:6} and Table \ref{table:5} we see that the commit transactions with less than 5 files, which are the most frequent types of commits, produce in average only 6.98\% of the total logical dependencies extracted from the systems. On the other hand, a small amount of very large commits (those with more than 20 source code files) can lead to a vast amount of logical dependencies. But very large commit transactions can be caused by merging development branches into the main branch. In this case the very large commit transaction is actually the sum of many other commit transactions made into a different branch and we cannot consider them as one single commit and definitely we cannot consider the logical dependencies extracted as valid logical dependencies. So a threshold to filter this kind of commit transactions is required.

Based on the results presented in Tables \ref{tab:ratio:comm} and \ref{tab:ratio:nocomm}, the number 
of changed files taken into consideration has an important influence over the ratio of the number  of 
logical dependencies to the number of structural dependencies.  If no threshold is set for the number of files in a commit (the cases in the last column in Tables \ref{tab:ratio:comm} and 
\ref{tab:ratio:nocomm} ) then the number of logical dependencies outnumbers the structural dependencies with a factor of up to 80. The maximum factor is measured in the case when no filtering is done on the number of occurrences (first row).  
In this case, we can not talk about logical dependencies, but about classes that happened to once change in the same time, by various reasons. The number of pairs of classes that happen to once change in the same time is up to 72 times bigger than the number of pairs of classes presenting structural dependencies.
%Tables \ref{table:5} and \ref{table:6}  present the detailed situation of the number of logical dependencies, under the conditions of a varying threshold for the number of files accepted in a commit, without any filtering according to the number of occurrences, for all test systems. These tables detail the situations summarized in the 1st rows of tables \ref{tab:ratio:comm} and respectively \ref{tab:ratio:nocomm}. 

When filtering is done according to conditions on the number of occurrences, we observe in Tables \ref{tab:ratio:comm} and \ref{tab:ratio:nocomm} that the values on the last column still do not fall below 20. This number is still too big to accept for logical dependencies.  It is clear that it is necessary to  put a threshold on the number of files accepted in a commit in order to filter out noise.


If we refer to the overlap between structural and logical dependencies, we can see in Tables \ref{tab:percSD:comm} and \ref{tab:percSD:nocomm} that the percentage of structural dependencies which are also logical dependencies is as well affected by setting a threshold on the number of files accepted in a commit. Setting a threshold leads to a smaller number of logical dependencies overall and this is what affects also the smaller number of structural dependencies that are also logical dependencies. However, we can see that the percentage of dependencies in the overlap decreases much slower than the total number of logical dependencies. For example, when setting  the $cs$ threshold at 10, we see in Table \ref{tab:ratio:comm} that the total number of logical dependencies decreases approx 20 times compared with no threshold. In the same time, we can see in Table \ref{tab:percSD:comm}  that the overlap between the logical and structural dependencies decreases less, only approx 3 times. This confirms the fact that the logical dependencies filtered out were not true dependencies. It is clear that setting a threshold on the maximum number of files accepted in a commit is essential for the quality of finding true logical dependencies.


\textit{\textbf{Question 3}}. Considering changes only in comments as valid can lead to additional logical dependencies? How many logical dependencies are introduced by considering comment changes as valid changes and in what percentage this can influence the analysis?

In order to assess the influence of comments, we compare pairwise Tables \ref{tab:ratio:comm} and \ref{tab:ratio:nocomm},  
Tables \ref{tab:percSD:comm} and \ref{tab:percSD:nocomm} and Tables \ref{tab:percLD:comm} and \ref{tab:percLD:nocomm}. 
We observe that, although there are some differences between pairs of measurements done in similar conditions with and without comments, the differences are not significant.

In the case of the ratio of the number of logical dependencies to the number of structural dependencies, from Tables \ref{tab:ratio:comm} and \ref{tab:ratio:nocomm} we can see that the maximum difference is for the values from the position of the first row, last column. Without comments, the value of the ratio is 67.1, compared to the value with comments which is 80.3. The decrease represents 13\% of the value with comments. In the case of the percentage of structural dependencies that are also logical dependencies, from Tables \ref{tab:percSD:comm} and \ref{tab:percSD:nocomm}, we can see that the maximum difference is also for the values from the first row, last column. Without comments, the overlap is 76.5, compared to the value with comments which is 71.1.  The decrease represents less than 6\% of the value with comments. We notice that the differences between the two cases are very small. %decrease percentage is smaller for the overlap than for the ratio of the total number of logical dependencies, thus we can say that eliminating changes due only to comments can slightly improve the quality of finding logical dependencies. 



\textit{\textbf{Question 4}}. How many occurrences of a logical dependency are needed to consider it a \textit{valid} logical dependency ? 

If we look at consecutive rows in Table \ref{tab:ratio:comm} or in Table \ref{tab:ratio:nocomm}, corresponding to increased threshold values for the number of occurrences, we can roughly say that  increasing by 1 the occurrence threshold while maintaining the other conditions reduces with more than half the total number of logical dependencies.  

In order to find the appropriate level of filtering out false logical dependencies, we assume as a rule of thumb that the number of logical dependencies should not be bigger that the number of structural dependencies. Choosing the most restrictive combination of thresholds (a commit size threshold of 5 files combined with an occurrence threshold of 4) leads to a number of logical dependencies which comes near to the number of structural dependencies.

%In tables \ref{tab:ratio:comm} or \ref{tab:ratio:nocomm}, we can see that we can obtain a number of logical dependencies which is between one quarter and one third of the number of the structural dependencies either by setting a commit size threshold of 5 files combined with an occurrence threshold of 2, or a commit size threshold of 10 files combined with an occurrence threshold of 3, or a commit size threshold of 20 files combined with an occurrence threshold of 4.  It is clear that increasing the threshold value for number of occurrences can be done only together with increasing the threshold value for maximum number of committed files. A more complex filtering condition can aggregate the 3 simple filtering cases, in the form: $((cs\leq 5) and (occ\geq 2)) or ((cs\leq 10) and (occ\geq 3)) or ((cs\leq 20) and (occ\geq 4))$. In this condition, $occ$ refers actually to 3 different counters, because every filtering on a different $cs$ has its own counter.  


\textit{\textbf{Question 5}}. How does filtering affect the overlap between structural and logical dependencies ? 

The overlap between structural and logical dependencies is given by the number of pairs of classes that have both structural and logical dependencies. We evaluate this overlap as a percentage relative to the number of structural dependencies in Tables \ref{tab:percSD:comm} and \ref{tab:percSD:nocomm}, respectively as  a percentage relative to the number of logical dependencies in Tables \ref{tab:percLD:comm} and \ref{tab:percLD:nocomm}.

A first observation from Tables \ref{tab:percSD:comm} and \ref{tab:percSD:nocomm} is that not all pairs of classes with structural dependencies co-change. The biggest value for the percentage of structural dependencies that are also logical dependencies is 76.5\% obtained in the case when no filterings are done.

From Tables \ref{tab:percLD:comm} and \ref{tab:percLD:nocomm} we notice that the percentage of logical dependencies which are also structural is always low to very low. This means that most co-changes are recorded between classes that have no structural dependencies to each other.   
 

\section {Future work}
\label{sec:futurework}

We consider that in the future, the validation of extracted logical dependencies will occur by using them to enhance dependency models used by different applications such as architectural reconstruction \cite{SoraConti}, \cite{PagerankENASE}, and evaluating the positive impact on their results.   

In this work we have extracted logical dependencies from all the revisions of the system, and structural dependencies from the last revision of the system. In future work we will take into account also structural dependencies from all the revisions of the system, in order to filter out the old logical dependencies.  Some logical dependencies may have been also structural in previous revisions of the system but not in the current one. Another way to investigate this problem could be to study the trend of occurrencies of co-changes: if co-changes between a pair of classes used to happen more often in the remote past than in the more recent past, it may be a sign that the problem causing the logical coupling has been removed in the mean time. 



\section{Conclusion}
\label{sec:Conclusion}
   
In this work we experimentally define methods to filter out the valid logical dependencies from co-changing classes. 

%Regarding whether co-changes which affect only comments contribute to logical dependencies, our study has found out that when ignoring commits which change only comments in source files, the quality of logical dependencies is slightly improved.

Our experiments show that the most important factors which affect the quality of logical dependencies are: the maximum size of commit transactions which are accepted to generate logical dependencies, and the minimum number of repeated occurrences for a co-change to be counted as logical dependency. 

We conclude that it is important to put a threshold on the maximum size of commit transactions which are accepted to generate logical dependencies. Only small commit transactions (changing up to 5 source code files) can be reliably used for introducing logical dependencies. We have also determined that small commit transactions are the most frequent kind of transactions, representing in average 80\% of all commit transactions. Under these conditions, we have determined that increasing the threshold for the minimum number of repeated occurrences for a co-change to be counted as a logical dependency reduces significantly the number of logical dependencies. In average, increasing with 1 the threshold for repeated occurrences determines a reduction to half for the number of logical dependencies.  A value of 4 for the threshold for repeated occurrences, combined with the condition of accepting only small commit transactions, already keeps the number of logical dependencies in the same range as the number of structural dependencies. Future work will investigate further the issue of repeated occurrences, analyzing also their trend in time. 

The analysis of the experimental data shows that logical dependencies are distinct from structural dependencies. Even after filtering, a very big percentage of logical dependencies are between classes without structural dependencies. This leads to the conclusion that including into dependency models also logical dependencies besides structural dependencies has the potential to improve analysis applications based on dependency models.

\section{Acknowledgements}
 \label{sec:ack}

This work was partially supported by a grant of the Romanian National Authority for Scientiï¬c Research and Innovation, CNCS/CCCDI UEFISCDI, project number PN-III-P2-2.1-PED-2016-0999, within PNCDI III.

 
\bibliographystyle{apalike}
{\small
\bibliography{logicaldepd}}
 

\end{document}

